#pragma once
// Secure, Sandboxed WASH Virtual Machine
// Ensures scripts cannot access hardware directly or execute arbitrary code

#include "engine_common.h"
#include "../scene/scene_system.h"
#include "../app/curated_api_extended.h"

namespace WispEngine {
namespace Script {

// === WASH BYTECODE AND VM ===

// WASH Bytecode Operations (secure, sandboxed instruction set)
enum WASHOpCode : uint8_t {
    // Stack operations
    OP_PUSH_NULL,       OP_PUSH_INT,        OP_PUSH_FLOAT,      OP_PUSH_STRING,
    OP_PUSH_BOOL,       OP_POP,             OP_DUP,             OP_SWAP,
    
    // Variables (local only - no global memory access)
    OP_LOAD_LOCAL,      OP_STORE_LOCAL,     OP_LOAD_FIELD,      OP_STORE_FIELD,
    
    // Arithmetic (safe operations only)
    OP_ADD,             OP_SUB,             OP_MUL,             OP_DIV,
    OP_MOD,             OP_NEG,             OP_ABS,
    
    // Comparison
    OP_EQ,              OP_NE,              OP_LT,              OP_LE,
    OP_GT,              OP_GE,
    
    // Logic
    OP_AND,             OP_OR,              OP_NOT,
    
    // Control flow (bounded jumps only)
    OP_JUMP,            OP_JUMP_IF_FALSE,   OP_CALL_API,        OP_RETURN,
    
    // CURATED API CALLS ONLY (no direct hardware/system access)
    OP_API_MOVE_ENTITY,     OP_API_SET_POSITION,    OP_API_GET_POSITION,
    OP_API_SET_VELOCITY,    OP_API_GET_VELOCITY,    OP_API_SET_SPRITE,
    OP_API_SET_ANIMATION,   OP_API_SET_LAYER,       OP_API_SET_VISIBLE,
    OP_API_DESTROY_ENTITY,  OP_API_SPAWN_ENTITY,
    
    OP_API_SET_CAMERA,      OP_API_GET_CAMERA,      OP_API_ADD_TILE,
    OP_API_REMOVE_TILE,     OP_API_SET_BACKGROUND,  OP_API_FOCUS_ENTITY,
    
    OP_API_PLAY_SOUND,      OP_API_SAVE_DATA,       OP_API_LOAD_DATA,
    OP_API_SET_TIMER,       OP_API_LOG_MESSAGE,
    
    OP_API_FIND_ENTITIES_BY_TYPE,   OP_API_FIND_ENTITIES_IN_RADIUS,
    OP_API_GET_ENTITY_TYPE,         OP_API_GET_CURRENT_PANEL,
    
    // Math functions (safe implementations)
    OP_MATH_SQRT,       OP_MATH_SIN,        OP_MATH_COS,        OP_MATH_CLAMP,
    OP_MATH_LERP,       OP_MATH_RANDOM,     OP_MATH_LENGTH,
    
    OP_HALT             // End execution
};

// WASH Script Value (sandboxed data types)
struct WASHValue {
    enum Type : uint8_t { NULL_VAL, BOOL_VAL, INT_VAL, FLOAT_VAL, STRING_VAL, UUID_VAL, VEC2_VAL };
    Type type;
    union {
        bool boolValue;
        int32_t intValue;
        float floatValue;
        uint32_t uuidValue;
        struct { float x, y; } vec2Value;
    };
    String stringValue;  // For strings only
    
    WASHValue() : type(NULL_VAL) { intValue = 0; }
    WASHValue(bool b) : type(BOOL_VAL), boolValue(b) {}
    WASHValue(int32_t i) : type(INT_VAL), intValue(i) {}
    WASHValue(float f) : type(FLOAT_VAL), floatValue(f) {}
    WASHValue(uint32_t uuid) : type(UUID_VAL), uuidValue(uuid) {}
    WASHValue(const String& s) : type(STRING_VAL), stringValue(s) { intValue = 0; }
};

// WASH Bytecode Container (loaded from ROM, never executed as native code)
struct WASHBytecode {
    static const uint16_t MAX_CODE_SIZE = 2048;      // Limited code size
    static const uint16_t MAX_CONSTANTS = 128;       // Limited constants
    static const uint16_t MAX_LOCALS = 32;           // Limited local variables
    
    uint8_t code[MAX_CODE_SIZE];
    uint16_t codeSize;
    
    WASHValue constants[MAX_CONSTANTS];
    uint16_t constantCount;
    
    String functionNames[8];        // Max 8 functions per script
    uint16_t functionOffsets[8];
    uint8_t functionCount;
    
    String scriptName;
    String scriptType;      // "entity", "panel", "global"
    uint32_t maxExecutionTime;  // Execution timeout in ms
    
    WASHBytecode() : codeSize(0), constantCount(0), functionCount(0), maxExecutionTime(100) {}
};

// UUID-based entity tracking for scripts
class UUIDTracker {
private:
    static const uint16_t MAX_TRACKED_ENTITIES = 128;
    struct EntityUUID {
        uint32_t uuid;              // Unique identifier (generated by Unity tools)
        uint16_t sceneEntityIndex;  // Index in current scene's entity array
        uint16_t panelId;           // Which panel owns this entity
        bool valid;                 // Is this UUID currently valid
        String entityType;          // Type name for findEntitiesByType()
    };
    
    EntityUUID trackedEntities[MAX_TRACKED_ENTITIES];
    uint16_t trackedCount;
    
public:
    UUIDTracker() : trackedCount(0) {}
    
    // Entity registration
    bool registerEntity(uint32_t uuid, uint16_t entityIndex, uint16_t panelId, const String& type);
    void unregisterEntity(uint32_t uuid);
    void clearPanel(uint16_t panelId);
    void clearAll();
    
    // UUID resolution
    uint16_t getEntityIndex(uint32_t uuid);
    uint16_t getPanelId(uint32_t uuid);
    String getEntityType(uint32_t uuid);
    bool isValid(uint32_t uuid);
    
    // Entity searching
    std::vector<uint32_t> findEntitiesByType(const String& type, uint16_t panelId);
    std::vector<uint32_t> findEntitiesInRadius(float x, float y, float radius, uint16_t panelId);
    
    // Debugging
    void dumpTrackedEntities();
    uint16_t getTrackedCount() const { return trackedCount; }
};

// WASH Virtual Machine (secure, sandboxed execution)
class WASHVirtualMachine {
private:
    // Execution stack (isolated from system memory)
    static const uint16_t STACK_SIZE = 64;
    WASHValue stack[STACK_SIZE];
    uint16_t stackTop;
    
    // Local variables (script-private memory)
    static const uint8_t MAX_LOCALS = 32;
    WASHValue locals[MAX_LOCALS];
    
    // Execution state
    const uint8_t* ip;              // Instruction pointer
    const uint8_t* codeStart;       // Start of bytecode
    const uint8_t* codeEnd;         // End of bytecode (bounds checking)
    WASHBytecode* currentBytecode;
    
    // Security and safety
    uint32_t executionStartTime;
    uint32_t maxExecutionTime;      // Timeout to prevent infinite loops
    uint32_t instructionCount;      // Count instructions for DoS prevention
    uint32_t maxInstructions;       // Max instructions per execution
    bool halted;
    bool error;
    String errorMessage;
    
    // API access (the ONLY way scripts can affect the system)
    WispCuratedAPIExtended* curatedAPI;
    UUIDTracker* uuidTracker;
    
    // Current execution context
    uint32_t contextUUID;           // Entity UUID (for entity scripts)
    uint16_t contextPanelId;        // Panel ID (for panel scripts)
    
public:
    WASHVirtualMachine();
    ~WASHVirtualMachine();
    
    // VM initialization
    bool initialize(WispCuratedAPIExtended* api, UUIDTracker* tracker);
    void shutdown();
    
    // Secure script execution
    bool executeScript(WASHBytecode* bytecode, const String& functionName, 
                      uint32_t entityUUID = 0, uint16_t panelId = 0);
    
    // VM state management
    void reset();
    bool isRunning() const { return !halted && !error; }
    bool hasError() const { return error; }
    const String& getError() const { return errorMessage; }
    
    // Performance monitoring
    uint32_t getExecutionTime() const;
    uint32_t getInstructionCount() const { return instructionCount; }
    
private:
    // Bytecode execution (secure)
    bool runBytecode();
    bool executeInstruction(WASHOpCode opcode);
    
    // Stack operations (bounds checked)
    bool push(const WASHValue& value);
    WASHValue pop();
    WASHValue peek(int offset = 0);
    bool stackCheck(int required);
    
    // CURATED API BRIDGE (the ONLY system interface)
    bool executeCuratedAPICall(WASHOpCode apiCall);
    
    // API call implementations (all go through curated API)
    bool apiMoveEntity();
    bool apiSetPosition();
    bool apiGetPosition();
    bool apiSetVelocity();
    bool apiGetVelocity();
    bool apiSetSprite();
    bool apiSetAnimation();
    bool apiSetLayer();
    bool apiSetVisible();
    bool apiDestroyEntity();
    bool apiSpawnEntity();
    
    bool apiSetCamera();
    bool apiGetCamera();
    bool apiAddTile();
    bool apiRemoveTile();
    bool apiSetBackground();
    bool apiFocusEntity();
    
    bool apiPlaySound();
    bool apiSaveData();
    bool apiLoadData();
    bool apiSetTimer();
    bool apiLogMessage();
    
    bool apiFindEntitiesByType();
    bool apiFindEntitiesInRadius();
    bool apiGetEntityType();
    bool apiGetCurrentPanel();
    
    // Math functions (safe implementations)
    bool mathSqrt();
    bool mathSin();
    bool mathCos();
    bool mathClamp();
    bool mathLerp();
    bool mathRandom();
    bool mathLength();
    
    // Security and safety checks
    bool boundsCheck(const uint8_t* ptr);
    bool timeoutCheck();
    bool instructionLimitCheck();
    void setError(const String& message);
    
    // Value type conversions (safe)
    bool toBoolean(const WASHValue& value);
    int32_t toInteger(const WASHValue& value);
    float toFloat(const WASHValue& value);
    String toString(const WASHValue& value);
    uint32_t toUUID(const WASHValue& value);
};

// WASH Script Instance (contains bytecode, no native code)
struct WASHScriptInstance {
    WASHBytecode* bytecode;         // Loaded from ROM (never executed directly)
    String scriptName;
    String scriptType;              // "entity", "panel", "global"
    uint32_t contextUUID;           // Entity UUID (for entity scripts)
    uint16_t contextPanelId;        // Panel ID (for panel scripts)
    
    // Runtime state
    bool active;
    bool paused;
    uint8_t priority;               // Execution priority
    uint32_t lastUpdateTime;
    
    // Performance tracking
    uint32_t totalExecutionTime;
    uint32_t executionCount;
    uint32_t errorCount;
    
    WASHScriptInstance() : bytecode(nullptr), contextUUID(0), contextPanelId(0),
                          active(true), paused(false), priority(100),
                          lastUpdateTime(0), totalExecutionTime(0),
                          executionCount(0), errorCount(0) {}
};

// === WASH RUNTIME MANAGER ===

class WASHRuntime {
private:
    WispCuratedAPIExtended* api;
    SceneManager* sceneManager;
    UUIDTracker uuidTracker;
    WASHVirtualMachine vm;
    
    // Script storage
    static const uint16_t MAX_SCRIPTS = 64;
    WASHScriptInstance scripts[MAX_SCRIPTS];
    uint16_t scriptCount;
    
    // Bytecode storage
    static const uint16_t MAX_BYTECODES = 32;
    WASHBytecode bytecodes[MAX_BYTECODES];
    uint16_t bytecodeCount;
    
    // Performance tracking
    uint32_t scriptsExecutedThisFrame;
    uint32_t totalExecutionTime;
    uint16_t errorCount;
    
public:
    WASHRuntime();
    ~WASHRuntime();
    
    // Initialization
    bool initialize(WispCuratedAPIExtended* apiPtr, SceneManager* sceneMgr);
    void shutdown();
    
    // === BYTECODE LOADING ===
    
    // Load bytecode from ROM
    bool loadBytecode(const String& name, const uint8_t* data, uint16_t size);
    void unloadBytecode(const String& name);
    void clearAllBytecode();
    WASHBytecode* findBytecode(const String& name);
    
    // === SCRIPT INSTANCE MANAGEMENT ===
    
    // Create script instances
    bool createEntityScript(const String& bytecode, uint32_t entityUUID);
    bool createPanelScript(const String& bytecode, uint16_t panelId);
    bool createGlobalScript(const String& bytecode);
    
    // Script instance management
    void destroyEntityScript(uint32_t entityUUID);
    void destroyPanelScript(uint16_t panelId);
    void destroyGlobalScript(const String& name);
    void destroyAllScripts();
    
    // === SCRIPT EXECUTION ===
    
    // Frame update
    void updateAllScripts();
    void updateEntityScripts();
    void updatePanelScripts();
    void updateGlobalScripts();
    
    // Event dispatch
    void dispatchInputEvent(WispInputSemantic input, bool pressed);
    void dispatchCollisionEvent(uint32_t entityA, uint32_t entityB);
    void dispatchAnimationEvent(uint32_t entityUUID, uint8_t animationId);
    void dispatchTimerEvent(uint16_t timerId);
    
    // === UUID MANAGEMENT ===
    
    // Entity UUID registration (called by scene system)
    bool registerEntity(uint32_t uuid, uint16_t entityIndex, uint16_t panelId, const String& type);
    void unregisterEntity(uint32_t uuid);
    void clearPanelEntities(uint16_t panelId);
    
    // Performance stats
    uint16_t getActiveScriptCount() const { return scriptCount; }
    uint32_t getFrameExecutionTime() const { return totalExecutionTime; }
    uint16_t getErrorCount() const { return errorCount; }
    
    // Debugging
    void dumpScriptState();
    void dumpVMState();
};

// === BYTECODE FORMAT IN ROM ===

/*
The Unity C# ASH compiler generates WASH bytecode with this structure:

Header (20 bytes):
- Magic number (4 bytes): "WASH"
- Version (2 bytes): e.g., 0x0100 = v1.0
- Script type (1 byte): 0=entity, 1=panel, 2=global
- Script name length (1 byte)
- Script name (variable)
- Function count (1 byte)
- Code size (2 bytes)
- Constant count (2 bytes)
- Max execution time (2 bytes): milliseconds

Function Table (variable):
- For each function:
  - Function name length (1 byte)
  - Function name (variable)
  - Function offset (2 bytes): offset in code section

Constants Section (variable):
- For each constant:
  - Type (1 byte): 0=null, 1=bool, 2=int, 3=float, 4=string, 5=uuid
  - Value (variable, depends on type)

Code Section (variable):
- Raw bytecode instructions

This compact binary format allows for efficient storage and loading.
*/

// === UNITY ASH COMPILER INTEGRATION ===

/*
The Unity ASH compiler process:

1. Parse ASH Script:
   - Tokenize and parse ASH source code
   - Generate abstract syntax tree
   - Validate against security constraints

2. Generate WASH Bytecode:
   - Compile AST to bytecode instructions
   - Include only permitted operations
   - Map ASH functions to bytecode
   - Register constants and variables

3. Security Checks:
   - Ensure only curated API calls are used
   - Validate memory safety
   - Check for infinite loops
   - Verify resource usage

4. Pack into ROM:
   - Add bytecode to ROM file
   - Include UUID mappings
   - Add to ROM manifest
*/

// === ERROR HANDLING ===

enum WASHError : uint8_t {
    WASH_OK,
    WASH_INVALID_UUID,
    WASH_SCRIPT_NOT_FOUND,
    WASH_MEMORY_ERROR,
    WASH_API_ERROR,
    WASH_EXECUTION_ERROR,
    WASH_TIMEOUT_ERROR,
    WASH_BOUNDS_ERROR,
    WASH_STACK_OVERFLOW,
    WASH_TYPE_ERROR,
    WASH_SECURITY_VIOLATION
};

// === EXAMPLES OF PERMITTED API CALLS ===

/*
ASH scripts can ONLY access functionality through these bytecode operations:

1. Entity Manipulation:
   OP_API_MOVE_ENTITY, OP_API_SET_POSITION, OP_API_GET_POSITION
   - All operations reference entities by UUID, not direct memory
   - All positions and movements restricted to valid screen bounds
   - Collision detection handled by engine, not directly by script

2. Panel Manipulation:
   OP_API_SET_CAMERA, OP_API_ADD_TILE, OP_API_SET_BACKGROUND
   - Camera movement bounded by panel limits
   - Tile operations subject to resource limits
   - All visual effects through predefined operations

3. System Operations:
   OP_API_PLAY_SOUND, OP_API_SAVE_DATA, OP_API_LOAD_DATA
   - Audio playback limited to existing sound resources
   - Save/load restricted to app's own data area
   - No direct file system access

4. Math Operations:
   OP_MATH_SQRT, OP_MATH_SIN, OP_MATH_COS
   - Safe implementations of math functions
   - No arbitrary memory access
   - Protected from overflow and NaN issues

This design ensures scripts cannot:
- Access hardware directly
- Read/write arbitrary memory
- Execute native code
- Bypass the sandbox
- Consume excessive resources
- Access other apps' data
*/

} // namespace Script
} // namespace WispEngine

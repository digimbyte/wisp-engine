// esp32_common.h - ESP-IDF Native Headers for ESP32-C6/S3
// 
// PURE ESP-IDF IMPLEMENTATION - NO ARDUINO SUPPORT
// This is the primary include for all Wisp Engine files on ESP32-C6/S3
// Provides ONLY native ESP-IDF functionality for maximum performance
// 
// ARCHITECTURE: Native ESP32-C6/S3 using ESP-IDF framework
// - All timing functions use esp_timer (microsecond precision)
// - All GPIO uses native ESP-IDF drivers (fastest possible)
// - All logging uses ESP_LOG system (structured logging)
// - NO Arduino compatibility - pure ESP32 native code only
//
#pragma once

// ESP-IDF Core Headers
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
#include "esp_system.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "esp_efuse.h"
#include "esp_random.h"
#include "esp_mac.h"
#include "driver/gpio.h"
#include "driver/spi_master.h"
// Note: I2S headers removed - use driver/i2s_std.h when needed
#include "esp_vfs_fat.h"
#include "sdmmc_cmd.h"
#include "esp_spiffs.h"
#include "esp_heap_caps.h"
#include "esp_attr.h"
#include "nvs_flash.h"
#include "esp_wifi.h"
// Note: Bluetooth headers moved to bt.h - ESP32-C6 only supports Bluetooth LE

// SD Card Support (ESP-IDF native)
#include "driver/sdmmc_host.h"
#include "driver/sdspi_host.h"

// Board-specific configurations
#ifdef PLATFORM_C6
#include "../../boards/esp32-c6_config.h"
#endif

#ifdef PLATFORM_S3
#include "../../boards/esp32-s3_config.h"  
#endif

// Standard C++ Headers (native)
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <cstdint>
#include <cstring>
#include <cmath>
#include <fstream>
#include <iostream>
#include <cstdarg>
#include <algorithm>  // For std::min, std::max, std::transform

// ESP-IDF LEDC (PWM) driver
#include "driver/ledc.h"

// Arduino mode constants (defined early for use in functions)
#define INPUT 0
#define OUTPUT 1
#define INPUT_PULLUP 2
#define HIGH 1
#define LOW 0

// Math constants
#ifndef PI
#define PI 3.14159265358979323846
#endif

// ESP32-native type definitions
using String = std::string;  // Use std::string as String type

// String extensions for Arduino compatibility
namespace StringExtensions {
    inline bool isEmpty(const std::string& str) {
        return str.empty();
    }
    
    inline size_t indexOf(const std::string& str, const std::string& search, size_t start = 0) {
        size_t pos = str.find(search, start);
        return (pos == std::string::npos) ? -1 : pos;
    }
    
    inline std::string substring(const std::string& str, size_t start, size_t length = std::string::npos) {
        return str.substr(start, length);
    }
    
    inline void toLowerCase(std::string& str) {
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);
    }
    
    inline void toUpperCase(std::string& str) {
        std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    }
}

// Native ESP32 timing functions (microsecond precision)
inline uint64_t micros() {
    return esp_timer_get_time();
}

inline uint32_t millis() {
    return esp_timer_get_time() / 1000;
}

inline void delay_ms(uint32_t ms) {
    vTaskDelay(pdMS_TO_TICKS(ms));
}

inline void delay_us(uint32_t us) {
    esp_rom_delay_us(us);
}

// Native ESP32 memory functions
inline uint32_t get_free_heap() {
    return esp_get_free_heap_size();
}

// Native ESP32 GPIO functions (replaces Arduino pinMode/digitalRead/digitalWrite)
inline void gpio_set_direction_input_pullup(gpio_num_t pin) {
    gpio_config_t io_conf = {};
    io_conf.intr_type = GPIO_INTR_DISABLE;
    io_conf.mode = GPIO_MODE_INPUT;
    io_conf.pin_bit_mask = (1ULL << pin);
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
    io_conf.pull_up_en = GPIO_PULLUP_ENABLE;
    gpio_config(&io_conf);
}

inline void gpio_set_direction_output(gpio_num_t pin) {
    gpio_config_t io_conf = {};
    io_conf.intr_type = GPIO_INTR_DISABLE;
    io_conf.mode = GPIO_MODE_OUTPUT;
    io_conf.pin_bit_mask = (1ULL << pin);
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
    io_conf.pull_up_en = GPIO_PULLUP_DISABLE;
    gpio_config(&io_conf);
}

inline int gpio_read_digital(gpio_num_t pin) {
    return gpio_get_level(pin);
}

inline void gpio_write_digital(gpio_num_t pin, int level) {
    gpio_set_level(pin, level);
}

// GPIO compatibility functions (no macros to avoid conflicts)
inline void setPinMode(int pin, int mode) {
    if (mode == INPUT_PULLUP) gpio_set_direction_input_pullup((gpio_num_t)pin);
    else if (mode == OUTPUT) gpio_set_direction_output((gpio_num_t)pin);
}

#define digitalRead(pin) gpio_read_digital((gpio_num_t)pin)
#define digitalWrite(pin, level) gpio_write_digital((gpio_num_t)pin, level)

// Arduino compatibility functions
inline void delayMicroseconds(uint32_t us) {
    esp_rom_delay_us(us);
}

// Native ESP32 math functions (defined early for use in other functions)
template<typename T>
constexpr T clamp(T value, T min_val, T max_val) {
    return (value < min_val) ? min_val : (value > max_val) ? max_val : value;
}

template<typename T>
constexpr T map_range(T x, T in_min, T in_max, T out_min, T out_max) {
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

// Arduino constrain function (uses clamp)
template<typename T>
inline T constrain(T value, T min_val, T max_val) {
    return clamp(value, min_val, max_val);
}

// Arduino map function compatibility
template<typename T>
inline T map(T value, T fromLow, T fromHigh, T toLow, T toHigh) {
    return (value - fromLow) * (toHigh - toLow) / (fromHigh - fromLow) + toLow;
}

// Arduino random function compatibility
inline long random(long max_val) {
    return esp_random() % max_val;
}

inline long random(long min_val, long max_val) {
    return min_val + (esp_random() % (max_val - min_val));
}

// Arduino compatibility LEDC (PWM) functions
inline bool ledcSetup(uint8_t channel, uint32_t freq, uint8_t resolution) {
    ledc_timer_config_t timer_config = {
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .duty_resolution = (ledc_timer_bit_t)resolution,
        .timer_num = (ledc_timer_t)(channel / 2),
        .freq_hz = freq,
        .clk_cfg = LEDC_AUTO_CLK
    };
    
    ledc_channel_config_t channel_config = {
        .gpio_num = -1,  // Will be set by ledcAttachPin
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .channel = (ledc_channel_t)channel,
        .intr_type = LEDC_INTR_DISABLE,
        .timer_sel = (ledc_timer_t)(channel / 2),
        .duty = 0,
        .hpoint = 0
    };
    
    esp_err_t timer_err = ledc_timer_config(&timer_config);
    esp_err_t channel_err = ledc_channel_config(&channel_config);
    return (timer_err == ESP_OK && channel_err == ESP_OK);
}

inline void ledcAttachPin(uint8_t pin, uint8_t channel) {
    gpio_set_direction_output((gpio_num_t)pin);
    ledc_set_pin(pin, LEDC_LOW_SPEED_MODE, (ledc_channel_t)channel);
}

inline void ledcWrite(uint8_t channel, uint32_t duty) {
    ledc_set_duty(LEDC_LOW_SPEED_MODE, (ledc_channel_t)channel, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, (ledc_channel_t)channel);
}

inline void ledcWriteTone(uint8_t channel, uint32_t freq) {
    if (freq > 0) {
        ledc_set_freq(LEDC_LOW_SPEED_MODE, (ledc_timer_t)(channel / 2), freq);
    }
}

inline uint32_t get_min_free_heap() {
    return esp_get_minimum_free_heap_size();
}

// Native ESP32 system functions
inline void restart_system() {
    esp_restart();
}

inline uint64_t get_chip_id() {
    uint64_t chipid = 0;
    uint8_t mac[6];
    esp_read_mac(mac, ESP_MAC_WIFI_STA);
    memcpy(&chipid, mac, 6);
    return chipid;
}

// Native ESP32 random functions
inline uint32_t random_uint32() {
    return esp_random();
}

inline int32_t random_range(int32_t min, int32_t max) {
    return min + (esp_random() % (max - min));
}

// GPIO definitions (ESP-IDF native)
#define GPIO_HIGH 1
#define GPIO_LOW 0

// Arduino compatibility macros for Serial (maps to ESP_LOG)
#define HEX 16  // For println/print hex formatting
class SerialClass {
public:
    void println() { ESP_LOGI("WISP", ""); }
    void println(const char* msg) { ESP_LOGI("WISP", "%s", msg); }
    void println(const std::string& msg) { ESP_LOGI("WISP", "%s", msg.c_str()); }
    void println(int val) { ESP_LOGI("WISP", "%d", val); }
    void println(uint16_t val) { ESP_LOGI("WISP", "%u", val); }
    void println(uint32_t val, int base = 10) { 
        if (base == 16) ESP_LOGI("WISP", "0x%X", val);
        else ESP_LOGI("WISP", "%u", val);
    }
    void println(size_t val) { ESP_LOGI("WISP", "%zu", val); }
    void println(float val) { ESP_LOGI("WISP", "%.2f", val); }
    
    void print(const char* msg) { ESP_LOGI("WISP", "%s", msg); }
    void print(const std::string& msg) { ESP_LOGI("WISP", "%s", msg.c_str()); }
    void print(int val) { ESP_LOGI("WISP", "%d", val); }
    void print(uint16_t val) { ESP_LOGI("WISP", "%u", val); }
    void print(uint32_t val) { ESP_LOGI("WISP", "%u", val); }
    void print(size_t val) { ESP_LOGI("WISP", "%zu", val); }
    void print(float val, int decimals = 2) { ESP_LOGI("WISP", "%.*f", decimals, val); }
    
    void printf(const char* format, ...) { 
        va_list args; va_start(args, format); 
        esp_log_writev(ESP_LOG_INFO, "WISP", format, args); 
        va_end(args); 
    }
};
extern SerialClass Serial;
